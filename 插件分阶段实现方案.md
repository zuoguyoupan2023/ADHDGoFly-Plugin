# ADHDGoFly 浏览器插件分阶段实现方案

## 总体策略

采用快速迭代的方式，从最简单的功能验证开始，逐步完善到完整产品。每个阶段都有可用的版本，便于测试和用户反馈。

## 阶段一：快速验证 (1-2 周)

### 目标

验证核心技术可行性，实现最基础的文本高亮功能。

### 功能范围

- 基础扩展框架
- 简单的中文分词和英文分词、标注、和高亮基本环节
- 中文基础词典、英文基础词典。（硬编码）
- 开关控制

### 核心文件结构

```
quick-validation/
├── manifest.json
├── content.js
├── popup.html
├── popup.js
└── styles.css
```

### 关键代码实现

#### manifest.json

````json
{
  "manifest_version": 3,
  "name": "ADHD Text Highlighter",
  "version": "0.1.0",
  "description": "Text highlighting for better reading",
  "permissions": ["activeTab", "storage"],
  "content_scripts": [{
    "matches": ["<all_urls>"],
    "js": ["content.js"],
    "css": ["styles.css"]
  }],
  "action": {
    "default_popup": "popup.html"
  }
}
```#
### content.js (核心逻辑)
```javascript
// 简单的英文词典
const SIMPLE_DICT = {
  // 名词
  'computer': 'n', 'book': 'n', 'table': 'n', 'person': 'n',
  // 动词
  'run': 'v', 'jump': 'v', 'read': 'v', 'write': 'v',
  // 形容词
  'good': 'a', 'bad': 'a', 'big': 'a', 'small': 'a'
};

class QuickHighlighter {
  constructor() {
    this.enabled = false;
    this.init();
  }

  init() {
    // 监听来自 popup 的消息
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      if (message.action === 'toggle') {
        this.toggle();
      }
    });

    // 检查存储的状态
    chrome.storage.local.get(['enabled'], (result) => {
      if (result.enabled) {
        this.enable();
      }
    });
  }

  toggle() {
    this.enabled ? this.disable() : this.enable();
  }

  enable() {
    this.enabled = true;
    this.processPage();
    chrome.storage.local.set({ enabled: true });
  }

  disable() {
    this.enabled = false;
    this.removHighlights();
    chrome.storage.local.set({ enabled: false });
  }

  processPage() {
    // 简单的文本节点查找
    const walker = document.createTreeWalker(
      document.body,
      NodeFilter.SHOW_TEXT,
      {
        acceptNode: (node) => {
          // 跳过脚本和样式标签
          const parent = node.parentElement;
          if (!parent) return NodeFilter.FILTER_REJECT;

          const tagName = parent.tagName.toLowerCase();
          if (['script', 'style', 'noscript'].includes(tagName)) {
            return NodeFilter.FILTER_REJECT;
          }

          return NodeFilter.FILTER_ACCEPT;
        }
      }
    );

    const textNodes = [];
    let node;
    while (node = walker.nextNode()) {
      textNodes.push(node);
    }

    // 处理每个文本节点
    textNodes.forEach(textNode => this.processTextNode(textNode));
  }

  processTextNode(textNode) {
    const text = textNode.textContent;
    if (!text.trim()) return;

    // 简单的英文分词（按空格和标点）
    const words = text.split(/(\s+|[.,!?;:])/);

    let html = '';
    words.forEach(word => {
      const cleanWord = word.toLowerCase().replace(/[^\w]/g, '');
      const pos = SIMPLE_DICT[cleanWord];

      if (pos) {
        html += `<span class="adhd-${pos}">${word}</span>`;
      } else {
        html += word;
      }
    });

    // 创建新的元素替换文本节点
    const wrapper = document.createElement('span');
    wrapper.innerHTML = html;
    wrapper.className = 'adhd-processed';

    textNode.parentNode.replaceChild(wrapper, textNode);
  }

  removHighlights() {
    // 移除所有高亮
    document.querySelectorAll('.adhd-processed').forEach(element => {
      element.outerHTML = element.textContent;
    });
  }
}

// 初始化
const highlighter = new QuickHighlighter();
````

#### popup.html

```html
<!DOCTYPE html>
<html>
  <head>
    <style>
      body {
        width: 200px;
        padding: 10px;
      }
      button {
        width: 100%;
        padding: 10px;
        margin: 5px 0;
      }
      .status {
        text-align: center;
        margin: 10px 0;
      }
    </style>
  </head>
  <body>
    <div class="status" id="status">状态检查中...</div>
    <button id="toggle">切换高亮</button>
    <script src="popup.js"></script>
  </body>
</html>
```

#### popup.js

```javascript
document.addEventListener("DOMContentLoaded", () => {
  const toggleBtn = document.getElementById("toggle");
  const statusDiv = document.getElementById("status");

  // 检查当前状态
  chrome.storage.local.get(["enabled"], (result) => {
    const enabled = result.enabled || false;
    updateUI(enabled);
  });

  // 切换按钮事件
  toggleBtn.addEventListener("click", () => {
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      chrome.tabs.sendMessage(tabs[0].id, { action: "toggle" });

      // 更新状态
      chrome.storage.local.get(["enabled"], (result) => {
        updateUI(!result.enabled);
      });
    });
  });

  function updateUI(enabled) {
    statusDiv.textContent = enabled ? "高亮已开启" : "高亮已关闭";
    toggleBtn.textContent = enabled ? "关闭高亮" : "开启高亮";
  }
});
```

#### styles.css

```css
/* 词性高亮样式 */
.adhd-n {
  color: #0066cc !important;
  background-color: rgba(0, 102, 204, 0.1) !important;
  border-radius: 2px !important;
}

.adhd-v {
  color: #cc0000 !important;
  background-color: rgba(204, 0, 0, 0.1) !important;
  border-radius: 2px !important;
}

.adhd-a {
  color: #009933 !important;
  background-color: rgba(0, 153, 51, 0.1) !important;
  border-radius: 2px !important;
}

/* 确保样式优先级 */
.adhd-processed span {
  font-family: inherit !important;
  font-size: inherit !important;
  line-height: inherit !important;
}
```

### 验证要点

1. 扩展能否正常加载和运行
2. 基础的英文词汇能否正确高亮
3. 开关功能是否正常
4. 是否影响网页原有功能

### 测试网站

- Wikipedia 英文页面
- 新闻网站（CNN, BBC）
- 技术博客

---

## 阶段二：基础实现 (2-3 周)

### 目标

实现完整的基础功能，支持中英文，引入真实词典。

### 新增功能

- 中文分词（简单版本）
- 真实词典文件
- 语言检测
- 页面结构识别
- 基础设置面板

### 文件结构

````
basic-implementation/
├── manifest.json
├── background/
│   └── service-worker.js
├── content/
│   ├── content.js
│   ├── segmenter.js
│   ├── language-detector.js
│   └── content.css
├── popup/
│   ├── popup.html
│   ├── popup.js
│   └── popup.css
├── options/
│   ├── options.html
│   └── options.js
├── dictionaries/
│   ├── en-basic.json
│   └── zh-basic.json
└── assets/
    └── icons/
```### 关键
代码实现

#### 语言检测器 (content/language-detector.js)
```javascript
class LanguageDetector {
  static detect(text) {
    const sample = text.slice(0, 100); // 取前100字符样本

    // 中文字符检测
    const chineseRatio = (sample.match(/[\u4e00-\u9fa5]/g) || []).length / sample.length;
    if (chineseRatio > 0.3) return 'zh';

    // 日文字符检测
    const japaneseRatio = (sample.match(/[\u3040-\u309f\u30a0-\u30ff]/g) || []).length / sample.length;
    if (japaneseRatio > 0.2) return 'ja';

    // 默认英文
    return 'en';
  }

  static detectPageLanguage() {
    // 检查 HTML lang 属性
    const htmlLang = document.documentElement.lang;
    if (htmlLang) {
      return htmlLang.split('-')[0];
    }

    // 检查页面主要文本内容
    const textContent = document.body.textContent.slice(0, 500);
    return this.detect(textContent);
  }
}
````

#### 中文分词器 (content/segmenter.js)

```javascript
class ChineseSegmenter {
  constructor(dictionary) {
    this.dict = dictionary;
    this.maxWordLen = 8; // 最大词长
  }

  // 前向最大匹配
  forwardMaxMatch(text) {
    const result = [];
    let start = 0;

    while (start < text.length) {
      let maxLen = 0;
      let word = "";

      // 从最大长度开始匹配
      for (
        let len = Math.min(this.maxWordLen, text.length - start);
        len > 0;
        len--
      ) {
        const candidate = text.substr(start, len);
        if (this.dict[candidate]) {
          maxLen = len;
          word = candidate;
          break;
        }
      }

      if (maxLen === 0) {
        // 未找到匹配，单字符处理
        result.push({
          text: text[start],
          pos: ["unknown"],
          start: start,
          end: start + 1,
        });
        start++;
      } else {
        result.push({
          text: word,
          pos: this.dict[word].pos,
          start: start,
          end: start + maxLen,
        });
        start += maxLen;
      }
    }

    return result;
  }

  // 后向最大匹配
  backwardMaxMatch(text) {
    const result = [];
    let end = text.length;

    while (end > 0) {
      let maxLen = 0;
      let word = "";

      for (let len = Math.min(this.maxWordLen, end); len > 0; len--) {
        const candidate = text.substr(end - len, len);
        if (this.dict[candidate]) {
          maxLen = len;
          word = candidate;
          break;
        }
      }

      if (maxLen === 0) {
        result.unshift({
          text: text[end - 1],
          pos: ["unknown"],
          start: end - 1,
          end: end,
        });
        end--;
      } else {
        result.unshift({
          text: word,
          pos: this.dict[word].pos,
          start: end - maxLen,
          end: end,
        });
        end -= maxLen;
      }
    }

    return result;
  }

  // 双向最大匹配
  segment(text) {
    const forward = this.forwardMaxMatch(text);
    const backward = this.backwardMaxMatch(text);

    // 选择分词数量少的结果
    if (forward.length <= backward.length) {
      return forward;
    } else {
      return backward;
    }
  }
}

class EnglishSegmenter {
  constructor(dictionary) {
    this.dict = dictionary;
  }

  segment(text) {
    const words = text.split(/(\s+|[.,!?;:()"])/);
    const result = [];
    let position = 0;

    words.forEach((word) => {
      const cleanWord = word.toLowerCase().replace(/[^\w]/g, "");
      const pos = this.dict[cleanWord] ? this.dict[cleanWord].pos : ["unknown"];

      result.push({
        text: word,
        pos: pos,
        start: position,
        end: position + word.length,
      });

      position += word.length;
    });

    return result;
  }
}
```

#### 页面处理器增强版

```javascript
class PageProcessor {
  constructor() {
    this.dictionaries = {};
    this.segmenters = {};
    this.loadDictionaries();
  }

  async loadDictionaries() {
    try {
      // 加载英文词典
      const enResponse = await fetch(
        chrome.runtime.getURL("dictionaries/en-basic.json")
      );
      this.dictionaries.en = await enResponse.json();
      this.segmenters.en = new EnglishSegmenter(this.dictionaries.en);

      // 加载中文词典
      const zhResponse = await fetch(
        chrome.runtime.getURL("dictionaries/zh-basic.json")
      );
      this.dictionaries.zh = await zhResponse.json();
      this.segmenters.zh = new ChineseSegmenter(this.dictionaries.zh);

      console.log("词典加载完成");
    } catch (error) {
      console.error("词典加载失败:", error);
    }
  }

  identifyContentAreas() {
    const areas = {
      titles: [],
      articles: [],
      paragraphs: [],
    };

    // 标题
    areas.titles = Array.from(document.querySelectorAll("h1,h2,h3,h4,h5,h6"));

    // 文章内容
    const articleSelectors = [
      "article",
      "main",
      '[role="main"]',
      ".content",
      ".article",
      ".post-content",
      ".entry-content",
    ];

    articleSelectors.forEach((selector) => {
      const elements = document.querySelectorAll(selector);
      areas.articles.push(...elements);
    });

    // 段落
    areas.paragraphs = Array.from(document.querySelectorAll("p"));

    return areas;
  }

  async processPage() {
    if (Object.keys(this.dictionaries).length === 0) {
      console.log("词典未加载完成，等待...");
      setTimeout(() => this.processPage(), 1000);
      return;
    }

    const areas = this.identifyContentAreas();

    // 按优先级处理
    await this.processElements(areas.titles);
    await this.processElements(areas.articles);
    await this.processElements(areas.paragraphs);
  }

  async processElements(elements) {
    for (const element of elements) {
      await this.processElement(element);
      // 添加小延迟避免阻塞
      await new Promise((resolve) => setTimeout(resolve, 5));
    }
  }

  async processElement(element) {
    const textNodes = this.getTextNodes(element);

    textNodes.forEach((textNode) => {
      const text = textNode.textContent.trim();
      if (!text) return;

      const language = LanguageDetector.detect(text);
      const segmenter = this.segmenters[language];

      if (!segmenter) {
        console.log(`不支持的语言: ${language}`);
        return;
      }

      const segments = segmenter.segment(text);
      this.applyHighlight(textNode, segments);
    });
  }

  getTextNodes(element) {
    const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, {
      acceptNode: (node) => {
        const parent = node.parentElement;
        if (!parent) return NodeFilter.FILTER_REJECT;

        const tagName = parent.tagName.toLowerCase();
        if (["script", "style", "noscript"].includes(tagName)) {
          return NodeFilter.FILTER_REJECT;
        }

        // 跳过已处理的节点
        if (parent.classList.contains("adhd-processed")) {
          return NodeFilter.FILTER_REJECT;
        }

        return NodeFilter.FILTER_ACCEPT;
      },
    });

    const textNodes = [];
    let node;
    while ((node = walker.nextNode())) {
      textNodes.push(node);
    }

    return textNodes;
  }

  applyHighlight(textNode, segments) {
    let html = "";

    segments.forEach((segment) => {
      const primaryPos = segment.pos[0];
      let className = "";

      switch (primaryPos) {
        case "n":
        case "noun":
          className = "adhd-noun";
          break;
        case "v":
        case "verb":
          className = "adhd-verb";
          break;
        case "a":
        case "adj":
        case "adjective":
          className = "adhd-adj";
          break;
        default:
          className = "adhd-other";
      }

      html += `<span class="${className}" data-pos="${primaryPos}">${segment.text}</span>`;
    });

    const wrapper = document.createElement("span");
    wrapper.innerHTML = html;
    wrapper.className = "adhd-processed";

    textNode.parentNode.replaceChild(wrapper, textNode);
  }
}
```

### 词典文件格式

#### en-basic.json

```json
{
  "computer": { "pos": ["n"], "freq": 1000 },
  "run": { "pos": ["v"], "freq": 800 },
  "good": { "pos": ["a"], "freq": 900 },
  "quickly": { "pos": ["adv"], "freq": 600 },
  "the": { "pos": ["det"], "freq": 5000 }
}
```

#### zh-basic.json

```json
{
  "电脑": { "pos": ["n"], "freq": 1000 },
  "运行": { "pos": ["v"], "freq": 800 },
  "好的": { "pos": ["a"], "freq": 900 },
  "快速": { "pos": ["a", "adv"], "freq": 600 },
  "这个": { "pos": ["pron"], "freq": 2000 }
}
```

### 测试要点

1. 中英文混合文本处理
2. 不同网站结构适应性
3. 分词准确性验证
4. 性能测试（大文本处理）

---

## 阶段三：中级实现 (3-4 周)

### 目标

完善用户体验，增加高级功能，优化性能。

### 新增功能

- 完整的设置面板
- 多种颜色主题
- 字体样式控制
- 官方词典下载
- 用户自定义词典
- 性能优化

### 关键功能实现

#### 设置面板 (options/options.js)

```javascript
class SettingsManager {
  constructor() {
    this.defaultSettings = {
      enabled: true,
      theme: "default",
      fontSize: "100%",
      lineHeight: "1.5",
      letterSpacing: "normal",
      enabledLanguages: ["zh", "en"],
      enabledDictionaries: ["zh-basic", "en-basic"],
    };

    this.init();
  }

  async init() {
    await this.loadSettings();
    this.bindEvents();
    this.updateUI();
  }

  async loadSettings() {
    const result = await chrome.storage.sync.get(this.defaultSettings);
    this.settings = { ...this.defaultSettings, ...result };
  }

  async saveSettings() {
    await chrome.storage.sync.set(this.settings);
    this.notifyContentScripts();
  }

  notifyContentScripts() {
    chrome.tabs.query({}, (tabs) => {
      tabs.forEach((tab) => {
        chrome.tabs
          .sendMessage(tab.id, {
            action: "settingsChanged",
            settings: this.settings,
          })
          .catch(() => {
            // 忽略无法发送消息的标签页
          });
      });
    });
  }

  bindEvents() {
    // 主题选择
    document.getElementById("theme-select").addEventListener("change", (e) => {
      this.settings.theme = e.target.value;
      this.saveSettings();
    });

    // 字体大小
    document.getElementById("font-size").addEventListener("input", (e) => {
      this.settings.fontSize = e.target.value + "%";
      this.saveSettings();
      this.updatePreview();
    });

    // 行高
    document.getElementById("line-height").addEventListener("input", (e) => {
      this.settings.lineHeight = e.target.value;
      this.saveSettings();
      this.updatePreview();
    });
  }

  updatePreview() {
    const preview = document.getElementById("preview");
    preview.style.fontSize = this.settings.fontSize;
    preview.style.lineHeight = this.settings.lineHeight;
    preview.style.letterSpacing = this.settings.letterSpacing;
  }
}
```

#### 词典管理器

```javascript
class DictionaryManager {
  constructor() {
    this.dictionaries = new Map();
    this.officialDictionaries = [
      { id: "zh-basic", name: "中文基础词典", size: "2.1MB", version: "1.0" },
      { id: "en-basic", name: "英文基础词典", size: "1.8MB", version: "1.0" },
      { id: "zh-advanced", name: "中文高级词典", size: "15MB", version: "1.0" },
    ];
  }

  async downloadOfficialDictionary(dictId) {
    const dict = this.officialDictionaries.find((d) => d.id === dictId);
    if (!dict) throw new Error("词典不存在");

    try {
      // 显示下载进度
      this.showDownloadProgress(dictId, 0);

      const response = await fetch(
        `https://api.adhdgofly.com/dictionaries/${dictId}.json`
      );
      if (!response.ok) throw new Error("下载失败");

      const data = await response.json();

      // 保存到本地存储
      await chrome.storage.local.set({
        [`dict_${dictId}`]: data,
        [`dict_${dictId}_meta`]: {
          downloadTime: Date.now(),
          version: dict.version,
          size: JSON.stringify(data).length,
        },
      });

      this.showDownloadProgress(dictId, 100);
      return data;
    } catch (error) {
      this.showDownloadError(dictId, error.message);
      throw error;
    }
  }

  async importUserDictionary(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();

      reader.onload = async (e) => {
        try {
          const data = JSON.parse(e.target.result);

          // 验证词典格式
          if (!this.validateDictionaryFormat(data)) {
            throw new Error("词典格式不正确");
          }

          const dictId = `user_${Date.now()}`;
          await chrome.storage.local.set({
            [`dict_${dictId}`]: data,
            [`dict_${dictId}_meta`]: {
              name: file.name,
              type: "user",
              importTime: Date.now(),
              size: JSON.stringify(data).length,
            },
          });

          resolve(dictId);
        } catch (error) {
          reject(error);
        }
      };

      reader.onerror = () => reject(new Error("文件读取失败"));
      reader.readAsText(file);
    });
  }

  validateDictionaryFormat(data) {
    // 检查是否为对象
    if (typeof data !== "object" || data === null) return false;

    // 检查词条格式
    for (const [word, info] of Object.entries(data)) {
      if (typeof word !== "string" || !word.trim()) return false;
      if (!info || !Array.isArray(info.pos) || info.pos.length === 0)
        return false;
    }

    return true;
  }
}
```

### 性能优化

#### Web Worker 分词处理

```javascript
// worker/segmentation-worker.js
class SegmentationWorker {
  constructor() {
    this.dictionaries = {};

    self.onmessage = (e) => {
      const { action, data } = e.data;

      switch (action) {
        case "loadDictionary":
          this.loadDictionary(data.language, data.dictionary);
          break;
        case "segment":
          this.segment(data.text, data.language, data.taskId);
          break;
      }
    };
  }

  loadDictionary(language, dictionary) {
    this.dictionaries[language] = dictionary;
    self.postMessage({ action: "dictionaryLoaded", language });
  }

  segment(text, language, taskId) {
    const segmenter = this.createSegmenter(language);
    const result = segmenter.segment(text);

    self.postMessage({
      action: "segmentComplete",
      taskId,
      result,
    });
  }

  createSegmenter(language) {
    const dictionary = this.dictionaries[language];

    if (language === "zh") {
      return new ChineseSegmenter(dictionary);
    } else {
      return new EnglishSegmenter(dictionary);
    }
  }
}

new SegmentationWorker();
```

---

## 阶段四：最终实现 (2-3 周)

### 目标

完善所有功能，优化用户体验，准备发布。

### 完善功能

- 完整的多语言支持
- 高级样式定制
- 数据导入导出
- 使用统计
- 错误报告
- 帮助文档

### 发布准备

1. **代码优化**: 压缩、混淆、性能优化
2. **测试覆盖**: 自动化测试、兼容性测试
3. **文档完善**: 用户手册、开发文档
4. **商店准备**: 描述、截图、隐私政策

### 最终文件结构

```
final-implementation/
├── manifest.json
├── background/
├── content/
├── popup/
├── options/
├── worker/
├── dictionaries/
├── assets/
├── docs/
├── tests/
└── build/
```

### 发布检查清单

- [ ] 功能完整性测试
- [ ] 性能基准测试
- [ ] 多浏览器兼容性
- [ ] 隐私政策合规
- [ ] 用户文档完整
- [ ] 商店资料准备

---

## 总结

这个分阶段方案确保了：

1. **快速验证**: 1-2 周内有可用版本
2. **渐进开发**: 每个阶段都有明确目标
3. **风险控制**: 技术难点分散到各阶段
4. **用户反馈**: 早期版本便于收集反馈
5. **质量保证**: 充分的测试和优化时间

总开发周期约 8-12 周，可根据实际情况调整各阶段时间分配。
